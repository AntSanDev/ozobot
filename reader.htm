<h1>Ozobot Code Reader</h1>
<p>Align center patch of pixels in the video frame with the "loading" area in OzoBlockly. The "Flash Code" colors are Red (R), Green (G), Blue (B), Cyan (C), Magenta (M), Yellow (Y), Black (K) and White (W), displayed below.</p>
<video id="video" style="display: none" width="640" height="480" autoplay></video>
<canvas id="canvas" width="640" height="480"></canvas>
<br />
<button id="start">Start</button>
<button id="stop">Stop</button>
<input id="code" type="text" style="width: 1000px" value="CRYCYMCRWKWRKWYBGRKWKWRWKCYKMRYKWKGCKBGYRBKWKYWCYCGCM" />
<button id="play">Play</button>
<h3 id="confidence"></h3>
<h4 id="debug"></h4>
<hr />
<script>
const WIDTH = 640,
      HEIGHT = 480;

function similarity(r0, g0, b0, r1, g1, b1) {
  // Euclidean distance in RGB space
  // Each of R, G, B, C, M, Y, K, W are at the extreeme corners of the RGB "cube" - very easy to distinguish
  let r = r0 - r1;
  let g = g0 - g1;
  let b = b0 - b1;
  return Math.sqrt(r * r + g * g + b * b);
}

let recording = false;
let playing = false;
let code = "";
let last = '';

function updateCode(c, m) {
  if (recording && !playing && c && m) {
    if (last != c && m < 50) {
      code += c;
      last = c;
    }
    document.getElementById("code").value = code;
  }
  document.getElementById("confidence").innerText = "Uncertainty: " + Math.rOund(m);
}

var codeIndex = 0;

function white(context) {
  let frame = context.getImageData(0, 0, WIDTH, HEIGHT);
  for (let x = 0; x < WIDTH; x++) {
    for (let y = 0; y < HEIGHT; y++) {
      let i = (x + y * WIDTH) * 4;
      frame.data[i + 0] = 255;
      frame.data[i + 1] = 255;
      frame.data[i + 2] = 255;
    }
  }
  context.putImageData(frame, 0, 0);
}

function onTick(context) {
  if (playing) {
    if (codeIndex == -1) {
      codeIndex++;
      white(context);
      setTimeout(function () { onTick(context); }, 5000);
    } else {
      var code = document.getElementById("code").value;
      if (codeIndex < code.length) {
        var c = code[codeIndex++];
        switch (c)
        {
          case 'R': cR = 255; cG =   0; cB =   0; break; // R
          case 'G': cR =   0; cG = 255; cB =   0; break; // G
          case 'B': cR =   0; cG =   0; cB = 255; break; // B
          case 'C': cR =   0, cG = 255, cB = 255; break; // G+B
          case 'M': cR = 255, cG =   0, cB = 255; break; // R+B
          case 'Y': cR = 255, cG = 255, cB =   0; break; // R+G
          case 'W': cR = 255, cG = 255, cB = 255; break; // R+G+B
          case 'K': cR =   0, cG =   0, cB =   0; break; // None
        }
        let frame = context.getImageData(0, 0, WIDTH, HEIGHT);
        for (let x = 0; x < WIDTH; x++) {
          for (let y = 0; y < HEIGHT; y++) {
            let i = (x + y * WIDTH) * 4;
            frame.data[i + 0] = cR;
            frame.data[i + 1] = cG;
            frame.data[i + 2] = cB;
          }
        }
        context.putImageData(frame, 0, 0);
        setTimeout(function () { onTick(context); }, 50);
      } else {
        white(context);
        playing = false;
        setTimeout(function () { onTick(context); }, 2000);
      }
    }
  } else {
    context.drawImage(video, 0, 0, WIDTH, HEIGHT);
    let frame = context.getImageData(0, 0, WIDTH, HEIGHT);

    // sample center patch of pixels
    const PATCH = 48; // pixels in the center
    const mx = WIDTH / 2;
    const my = HEIGHT / 2;
    let r = 0,
        g = 0,
        b = 0;
    for (let x = mx - PATCH; x < mx + PATCH; x++) {
      for (let y = my - PATCH; y < my + PATCH; y++) {
        let i = (x + y * WIDTH) * 4;
        r += frame.data[i + 0];
        g += frame.data[i + 1];
        b += frame.data[i + 2];
      }
    }
    const TOTAL_PATCH = (PATCH * 2) * (PATCH * 2);
    r /= TOTAL_PATCH; // average
    g /= TOTAL_PATCH;
    b /= TOTAL_PATCH;
    document.getElementById('debug').innerHTML = "R: " + Math.round(r) + "G: " + Math.round(g) + "B: " + Math.round(b);

    var rr = 140, rg = 32,  rb = 37; // calibrated
    var gr = 48,  gg = 135, gb = 60;
    var br = 7,   bg = 1,   bb = 171;
    var cr = 23,  cg = 164, cb = 169;
    var mr = 135, mg = 1,   mb = 164;
    var yr = 130, yg = 120, yb = 38;
    var wr = 154, wg = 150, wb = 164;
    var kr = 30,  kg = 30,  kb = 38;

    // detect color
    let rSim = similarity(r, g, b, rr, rg, rb); // R
    let gSim = similarity(r, g, b, gr, gg, gb); // G
    let bSim = similarity(r, g, b, br, bg, bb); // B
    let cSim = similarity(r, g, b, cr, cg, cb); // G+B
    let mSim = similarity(r, g, b, mr, mg, mb); // R+B
    let ySim = similarity(r, g, b, yr, yg, yb); // R+G
    let wSim = similarity(r, g, b, wr, wg, wb); // R+G+B
    let kSim = similarity(r, g, b, kr, kg, kb); // None

    let c = '?';
    let cR = 0;
    let cG = 0;
    let cB = 0;
    let m = 1000000;
    if (rSim < m) { c = 'R'; m = rSim; cR = 255; cG =   0; cB =   0; } // R
    if (gSim < m) { c = 'G'; m = gSim; cR =   0; cG = 255; cB =   0; } // G
    if (bSim < m) { c = 'B'; m = bSim; cR =   0; cG =   0; cB = 255; } // B
    if (cSim < m) { c = 'C'; m = cSim; cR =   0, cG = 255, cB = 255; } // G+B
    if (mSim < m) { c = 'M'; m = mSim; cR = 255, cG =   0, cB = 255; } // R+B
    if (ySim < m) { c = 'Y'; m = ySim; cR = 255, cG = 255, cB =   0; } // R+G
    if (wSim < m) { c = 'W'; m = wSim; cR = 255, cG = 255, cB = 255; } // R+G+B
    if (kSim < m) { c = 'K'; m = kSim; cR =   0, cG =   0, cB =   0; } // None
    updateCode(c, m);

    // display detected color
    for (let x = mx - (PATCH + 4); x < mx + PATCH + 4; x++) {
      for (let y = my - (PATCH + 4); y < my + PATCH + 4; y++) {
        let i = (x + y * WIDTH) * 4;
        frame.data[i + 0] = cR;
        frame.data[i + 1] = cG;
        frame.data[i + 2] = cB;
      }
    }

    // display average patch
    for (let x = mx - PATCH; x < mx + PATCH; x++) {
      for (let y = my - PATCH; y < my + PATCH; y++) {
        let i = (x + y * WIDTH) * 4;
        frame.data[i + 0] = r;
        frame.data[i + 1] = g;
        frame.data[i + 2] = b;
      }
    }

    context.putImageData(frame, 0, 0);
    setTimeout(function () { onTick(context); }, 0);
  }
}

window.addEventListener("DOMContentLoaded", function() {
  // Grab elements, create settings, etc.
  var canvas = document.getElementById("canvas"),
      context = canvas.getContext("2d"),
      video = document.getElementById("video"),
      videoObj = { "video": true },
      errBack = function(error) {
        Alert("Video capture error: ", error.code); 
      };

  // Put video listeners into place
  if(navigator.getUserMedia) { // Standard
    navigator.getUserMedia(videoObj, function(stream) {
      video.src = stream;
      video.play();
    }, errBack);
  } else if(navigator.webkitGetUserMedia) { // WebKit-prefixed
    navigator.webkitGetUserMedia(videoObj, function(stream){
      video.src = window.webkitURL.createObjectURL(stream);
      video.play();
    }, errBack);
  }
  else if(navigator.mozGetUserMedia) { // Firefox-prefixed
    navigator.mozGetUserMedia(videoObj, function(stream){
      video.src = window.URL.createObjectURL(stream);
      video.play();
    }, errBack);
  }

  document.getElementById("start").addEventListener("click", function() {
    recording = true;
    code = "";
    updateCode();
  });

  document.getElementById("stop").addEventListener("click", function() {
    recording = false;
  });

  document.getElementById("play").addEventListener("click", function() {
    codeIndex = -1;
    playing = true;
  });

  setTimeout(function () { onTick(context); }, 0);
}, false);
</script>
